--- a/barDeco.cpp
+++ b/barDeco.cpp
@@ -40,6 +40,7 @@
 
     m_pTextTex    = makeShared<CTexture>();
     m_pButtonsTex = makeShared<CTexture>();
+    m_pBarBgTex   = makeShared<CTexture>();
 
     g_pAnimationManager->createAnimation(CHyprColor{**PCOLOR}, m_cRealBarColor, g_pConfigManager->getAnimationPropertyConfig("border"), pWindow, AVARDAMAGE_NONE);
     m_cRealBarColor->setUpdateCallback([&](auto) { damageEntire(); });
@@ -411,6 +412,18 @@
                                                          std::round(((bufferSize.x - scaledBorderSize) / 2.0 - layoutWidth / PANGO_SCALE / 2.0));
     const int yOffset = std::round((bufferSize.y / 2.0 - layoutHeight / PANGO_SCALE / 2.0));
 
+    // draw text shadow first if enabled
+    static auto* const PTEXTSHADOW = (Hyprlang::INT* const*)HyprlandAPI::getConfigValue(PHANDLE, "plugin:hyprbars:text_shadow_size")->getDataStaticPtr();
+    static auto* const PTEXTSHADOWCOLOR = (Hyprlang::INT* const*)HyprlandAPI::getConfigValue(PHANDLE, "plugin:hyprbars:text_shadow_color")->getDataStaticPtr();
+    const int shadowSize = **PTEXTSHADOW;
+    if (shadowSize > 0) {
+        CHyprColor shadowColor = CHyprColor(**PTEXTSHADOWCOLOR);
+        cairo_set_source_rgba(CAIRO, shadowColor.r, shadowColor.g, shadowColor.b, shadowColor.a * COLOR.a);
+        cairo_move_to(CAIRO, xOffset + shadowSize * scale, yOffset + shadowSize * scale);  // diagonal (down-right)
+        pango_cairo_show_layout(CAIRO, layout);
+    }
+
+    cairo_set_source_rgba(CAIRO, COLOR.r, COLOR.g, COLOR.b, COLOR.a);
     cairo_move_to(CAIRO, xOffset, yOffset);
     pango_cairo_show_layout(CAIRO, layout);
 
@@ -565,6 +578,65 @@
     }
 }
 
+void CHyprBar::renderBarBackground(const Vector2D& bufferSize, const float scale, const CHyprColor& color, int rounding, const std::optional<CHyprColor>& forcedSepColor) {
+    const auto CAIROSURFACE = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, bufferSize.x, bufferSize.y);
+    const auto CAIRO = cairo_create(CAIROSURFACE);
+
+    cairo_save(CAIRO);
+    cairo_set_operator(CAIRO, CAIRO_OPERATOR_CLEAR);
+    cairo_paint(CAIRO);
+    cairo_restore(CAIRO);
+
+    // create path with rounded top corners only
+    // use ceil to ensure full coverage (avoid sub-pixel gaps at edges)
+    const double r = rounding * scale;
+    const double w = std::ceil(bufferSize.x);
+    const double h = std::ceil(bufferSize.y);
+    cairo_new_path(CAIRO);
+    cairo_move_to(CAIRO, r, 0);
+    cairo_line_to(CAIRO, w - r, 0);
+    cairo_arc(CAIRO, w - r, r, r, -M_PI/2, 0);  // top-right
+    cairo_line_to(CAIRO, w, h);
+    cairo_line_to(CAIRO, 0, h);
+    cairo_line_to(CAIRO, 0, r);
+    cairo_arc(CAIRO, r, r, r, M_PI, 3*M_PI/2);  // top-left
+    cairo_close_path(CAIRO);
+
+    // solid color fill
+    cairo_set_source_rgba(CAIRO, color.b, color.g, color.r, color.a);
+    cairo_fill_preserve(CAIRO);
+    cairo_new_path(CAIRO);
+
+    // draw separator line at bottom
+    static auto* const PSEPARATOR = (Hyprlang::INT* const*)HyprlandAPI::getConfigValue(PHANDLE, "plugin:hyprbars:bar_separator_size")->getDataStaticPtr();
+    const int separatorSize = **PSEPARATOR;
+    if (separatorSize > 0) {
+        static auto* const PSEPARATORCOLOR = (Hyprlang::INT* const*)HyprlandAPI::getConfigValue(PHANDLE, "plugin:hyprbars:bar_separator_color")->getDataStaticPtr();
+        CHyprColor sepColor = forcedSepColor.value_or(CHyprColor(**PSEPARATORCOLOR));
+        const int scaledSize = std::max(1, (int)(separatorSize * scale));
+        cairo_set_source_rgba(CAIRO, sepColor.b, sepColor.g, sepColor.r, sepColor.a);
+        cairo_rectangle(CAIRO, 0, bufferSize.y - scaledSize, bufferSize.x, scaledSize);
+        cairo_fill(CAIRO);
+    }
+
+    cairo_surface_flush(CAIROSURFACE);
+
+    const auto DATA = cairo_image_surface_get_data(CAIROSURFACE);
+    m_pBarBgTex->allocate();
+    glBindTexture(GL_TEXTURE_2D, m_pBarBgTex->m_texID);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, bufferSize.x, bufferSize.y, 0, GL_RGBA, GL_UNSIGNED_BYTE, DATA);
+
+    cairo_destroy(CAIRO);
+    cairo_surface_destroy(CAIROSURFACE);
+}
+
+bool CHyprBar::hasSeparator() {
+    static auto* const PSEPARATOR = (Hyprlang::INT* const*)HyprlandAPI::getConfigValue(PHANDLE, "plugin:hyprbars:bar_separator_size")->getDataStaticPtr();
+    return **PSEPARATOR > 0;
+}
+
 void CHyprBar::draw(PHLMONITOR pMonitor, const float& a) {
     static auto* const PENABLED = (Hyprlang::INT* const*)HyprlandAPI::getConfigValue(PHANDLE, "plugin:hyprbars:enabled")->getDataStaticPtr();
 
@@ -670,10 +742,16 @@
         glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
     }
 
-    if (SHOULDBLUR)
-        g_pHyprOpenGL->renderRect(titleBarBox, color, {.round = scaledRounding, .roundingPower = m_pWindow->roundingPower(), .blur = true, .blurA = a});
-    else
-        g_pHyprOpenGL->renderRect(titleBarBox, color, {.round = scaledRounding, .roundingPower = m_pWindow->roundingPower()});
+    // render blur pass first if enabled
+    CBox bgBox = {titleBarBox.x, titleBarBox.y, (int)std::ceil(BARBUF.x), (int)std::ceil(BARBUF.y)};
+    if (SHOULDBLUR) {
+        // render transparent rect with blur to get the blur effect behind the bar
+        g_pHyprOpenGL->renderRect(bgBox, CHyprColor(0, 0, 0, 0), {.round = scaledRounding, .roundingPower = m_pWindow->roundingPower(), .blur = true, .blurA = a});
+    }
+
+    // render bar background with rounded top corners only (via Cairo texture)
+    renderBarBackground(BARBUF, pMonitor->m_scale, color, ROUNDING, m_bForcedSeparatorColor);
+    g_pHyprOpenGL->renderTexture(m_pBarBgTex, bgBox, {.a = 1.0f});
 
     // render title
     if (**PENABLETITLE && (m_szLastTitle != PWINDOW->m_title || m_bWindowSizeChanged || m_pTextTex->m_texID == 0 || m_bTitleColorChanged)) {
@@ -732,7 +810,7 @@
 }
 
 eDecorationLayer CHyprBar::getDecorationLayer() {
-    return DECORATION_LAYER_UNDER;
+    return DECORATION_LAYER_OVER;
 }
 
 uint64_t CHyprBar::getDecorationFlags() {
@@ -762,9 +840,10 @@
     auto       prevHidden           = m_hidden;
     auto       prevForcedTitleColor = m_bForcedTitleColor;
 
-    m_bForcedBarColor   = std::nullopt;
-    m_bForcedTitleColor = std::nullopt;
-    m_hidden            = false;
+    m_bForcedBarColor       = std::nullopt;
+    m_bForcedTitleColor     = std::nullopt;
+    m_bForcedSeparatorColor = std::nullopt;
+    m_hidden                = false;
 
     if (PWINDOW->m_ruleApplicator->m_otherProps.props.contains(g_pGlobalState->nobarRuleIdx))
         m_hidden = truthy(PWINDOW->m_ruleApplicator->m_otherProps.props.at(g_pGlobalState->nobarRuleIdx)->effect);
@@ -772,6 +851,8 @@
         m_bForcedBarColor = CHyprColor(configStringToInt(PWINDOW->m_ruleApplicator->m_otherProps.props.at(g_pGlobalState->barColorRuleIdx)->effect).value_or(0));
     if (PWINDOW->m_ruleApplicator->m_otherProps.props.contains(g_pGlobalState->titleColorRuleIdx))
         m_bForcedTitleColor = CHyprColor(configStringToInt(PWINDOW->m_ruleApplicator->m_otherProps.props.at(g_pGlobalState->titleColorRuleIdx)->effect).value_or(0));
+    if (PWINDOW->m_ruleApplicator->m_otherProps.props.contains(g_pGlobalState->separatorColorRuleIdx))
+        m_bForcedSeparatorColor = CHyprColor(configStringToInt(PWINDOW->m_ruleApplicator->m_otherProps.props.at(g_pGlobalState->separatorColorRuleIdx)->effect).value_or(0));
 
     if (prevHidden != m_hidden)
         g_pDecorationPositioner->repositionDeco(this);
--- a/barDeco.hpp
+++ b/barDeco.hpp
@@ -55,6 +55,7 @@
 
     SP<CTexture>              m_pTextTex;
     SP<CTexture>              m_pButtonsTex;
+    SP<CTexture>              m_pBarBgTex;
 
     bool                      m_bWindowSizeChanged = false;
     bool                      m_hidden             = false;
@@ -64,6 +65,7 @@
     bool                      m_bWindowHasFocus    = false;
     std::optional<CHyprColor> m_bForcedBarColor;
     std::optional<CHyprColor> m_bForcedTitleColor;
+    std::optional<CHyprColor> m_bForcedSeparatorColor;
 
     Time::steady_tp           m_lastMouseDown = Time::steadyNow();
 
@@ -76,6 +78,8 @@
     void                      renderText(SP<CTexture> out, const std::string& text, const CHyprColor& color, const Vector2D& bufferSize, const float scale, const int fontSize);
     void                      renderBarButtons(const Vector2D& bufferSize, const float scale);
     void                      renderBarButtonsText(CBox* barBox, const float scale, const float a);
+    void                      renderBarBackground(const Vector2D& bufferSize, const float scale, const CHyprColor& color, int rounding, const std::optional<CHyprColor>& forcedSepColor);
+    bool                      hasSeparator();
     void                      damageOnButtonHover();
 
     bool                      inputIsValid();
--- a/globals.hpp
+++ b/globals.hpp
@@ -23,6 +23,7 @@
     uint32_t                  nobarRuleIdx = 0;
     uint32_t                  barColorRuleIdx = 0;
     uint32_t                  titleColorRuleIdx = 0;
+    uint32_t                  separatorColorRuleIdx = 0;
 };
 
 inline UP<SGlobalState> g_pGlobalState;
--- a/main.cpp
+++ b/main.cpp
@@ -122,10 +122,11 @@
         throw std::runtime_error("[hb] Version mismatch");
     }
 
-    g_pGlobalState                    = makeUnique<SGlobalState>();
-    g_pGlobalState->nobarRuleIdx      = Desktop::Rule::windowEffects()->registerEffect("hyprbars:no_bar");
-    g_pGlobalState->barColorRuleIdx   = Desktop::Rule::windowEffects()->registerEffect("hyprbars:bar_color");
-    g_pGlobalState->titleColorRuleIdx = Desktop::Rule::windowEffects()->registerEffect("hyprbars:title_color");
+    g_pGlobalState                        = makeUnique<SGlobalState>();
+    g_pGlobalState->nobarRuleIdx          = Desktop::Rule::windowEffects()->registerEffect("hyprbars:no_bar");
+    g_pGlobalState->barColorRuleIdx       = Desktop::Rule::windowEffects()->registerEffect("hyprbars:bar_color");
+    g_pGlobalState->titleColorRuleIdx     = Desktop::Rule::windowEffects()->registerEffect("hyprbars:title_color");
+    g_pGlobalState->separatorColorRuleIdx = Desktop::Rule::windowEffects()->registerEffect("hyprbars:separator_color");
 
     static auto P = HyprlandAPI::registerCallbackDynamic(PHANDLE, "openWindow", [&](void* self, SCallbackInfo& info, std::any data) { onNewWindow(self, data); });
     // static auto P2 = HyprlandAPI::registerCallbackDynamic(PHANDLE, "closeWindow", [&](void* self, SCallbackInfo& info, std::any data) { onCloseWindow(self, data); });
@@ -133,6 +134,10 @@
                                                           [&](void* self, SCallbackInfo& info, std::any data) { onUpdateWindowRules(std::any_cast<PHLWINDOW>(data)); });
 
     HyprlandAPI::addConfigValue(PHANDLE, "plugin:hyprbars:bar_color", Hyprlang::INT{*configStringToInt("rgba(33333388)")});
+    HyprlandAPI::addConfigValue(PHANDLE, "plugin:hyprbars:bar_separator_size", Hyprlang::INT{0});
+    HyprlandAPI::addConfigValue(PHANDLE, "plugin:hyprbars:bar_separator_color", Hyprlang::INT{*configStringToInt("rgba(00000033)")});
+    HyprlandAPI::addConfigValue(PHANDLE, "plugin:hyprbars:text_shadow_size", Hyprlang::INT{0});
+    HyprlandAPI::addConfigValue(PHANDLE, "plugin:hyprbars:text_shadow_color", Hyprlang::INT{*configStringToInt("rgba(00000066)")});
     HyprlandAPI::addConfigValue(PHANDLE, "plugin:hyprbars:bar_height", Hyprlang::INT{15});
     HyprlandAPI::addConfigValue(PHANDLE, "plugin:hyprbars:col.text", Hyprlang::INT{*configStringToInt("rgba(ffffffff)")});
     HyprlandAPI::addConfigValue(PHANDLE, "plugin:hyprbars:bar_text_size", Hyprlang::INT{10});
@@ -174,5 +179,6 @@
 
     Desktop::Rule::windowEffects()->unregisterEffect(g_pGlobalState->barColorRuleIdx);
     Desktop::Rule::windowEffects()->unregisterEffect(g_pGlobalState->titleColorRuleIdx);
+    Desktop::Rule::windowEffects()->unregisterEffect(g_pGlobalState->separatorColorRuleIdx);
     Desktop::Rule::windowEffects()->unregisterEffect(g_pGlobalState->nobarRuleIdx);
 }
