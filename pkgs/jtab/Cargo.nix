# This file was @generated by crate2nix 0.11.0 with the command:
#   "generate"
# See https://github.com/kolloch/crate2nix for more info.
{
  nixpkgs ? <nixpkgs>,
  pkgs ? import nixpkgs {config = {};},
  lib ? pkgs.lib,
  stdenv ? pkgs.stdenv,
  buildRustCrateForPkgs ? pkgs: pkgs.buildRustCrate,
  # This is used as the `crateOverrides` argument for `buildRustCrate`.
  defaultCrateOverrides ? pkgs.defaultCrateOverrides,
  # The features to enable for the root_crate or the workspace_members.
  rootFeatures ? ["default"],
  # If true, throw errors instead of issueing deprecation warnings.
  strictDeprecation ? false,
  # Used for conditional compilation based on CPU feature detection.
  targetFeatures ? [],
  # Whether to perform release builds: longer compile times, faster binaries.
  release ? true,
  # Additional crate2nix configuration if it exists.
  crateConfig ?
    if builtins.pathExists ./crate-config.nix
    then pkgs.callPackage ./crate-config.nix {}
    else {},
}: let
  _src = pkgs.fetchFromGitHub {
    owner = "wlezzar";
    repo = "jtab";
    rev = "d6c7fd163979c4f4ec3f950fca70f9495b4c3ed3";
    hash = "sha256-NH2OVOMs+p/pV7Lt0sYzcFhT2SCmMROJ2L81UPaMNb4=";
  };
in rec {
  #
  # "public" attributes that we attempt to keep stable with new versions of crate2nix.
  #

  rootCrate = rec {
    packageId = "jtab";

    # Use this attribute to refer to the derivation building your root crate package.
    # You can override the features with rootCrate.build.override { features = [ "default" "feature1" ... ]; }.
    build = internal.buildRustCrateWithFeatures {
      inherit packageId;
    };

    # Debug support which might change between releases.
    # File a bug if you depend on any for non-debug work!
    debug = internal.debugCrate {inherit packageId;};
  };
  # Refer your crate build derivation by name here.
  # You can override the features with
  # workspaceMembers."${crateName}".build.override { features = [ "default" "feature1" ... ]; }.
  workspaceMembers = {
    "jtab" = rec {
      packageId = "jtab";
      build = internal.buildRustCrateWithFeatures {
        packageId = "jtab";
      };

      # Debug support which might change between releases.
      # File a bug if you depend on any for non-debug work!
      debug = internal.debugCrate {inherit packageId;};
    };
  };

  # A derivation that joins the outputs of all workspace members together.
  allWorkspaceMembers = pkgs.symlinkJoin {
    name = "all-workspace-members";
    paths = let
      members = builtins.attrValues workspaceMembers;
    in
      builtins.map (m: m.build) members;
  };

  #
  # "internal" ("private") attributes that may change in every new version of crate2nix.
  #

  internal = rec {
    # Build and dependency information for crates.
    # Many of the fields are passed one-to-one to buildRustCrate.
    #
    # Noteworthy:
    # * `dependencies`/`buildDependencies`: similar to the corresponding fields for buildRustCrate.
    #   but with additional information which is used during dependency/feature resolution.
    # * `resolvedDependencies`: the selected default features reported by cargo - only included for debugging.
    # * `devDependencies` as of now not used by `buildRustCrate` but used to
    #   inject test dependencies into the build

    crates = {
      "aho-corasick" = rec {
        crateName = "aho-corasick";
        version = "1.1.2";
        edition = "2021";
        sha256 = "1w510wnixvlgimkx1zjbvlxh6xps2vjgfqgwf5a6adlbjp5rv5mj";
        libName = "aho_corasick";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "memchr";
            packageId = "memchr";
            optional = true;
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "default" = ["std" "perf-literal"];
          "logging" = ["dep:log"];
          "perf-literal" = ["dep:memchr"];
          "std" = ["memchr?/std"];
        };
        resolvedDefaultFeatures = ["perf-literal" "std"];
      };
      "anyhow" = rec {
        crateName = "anyhow";
        version = "1.0.79";
        edition = "2018";
        sha256 = "1ji5irqiwr8yprgqj8zvnli7zd7fz9kzaiddq44jnrl2l289h3h8";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        features = {
          "backtrace" = ["dep:backtrace"];
          "default" = ["std"];
        };
        resolvedDefaultFeatures = ["default" "std"];
      };
      "atty" = rec {
        crateName = "atty";
        version = "0.2.14";
        edition = "2015";
        sha256 = "1s7yslcs6a28c5vz7jwj63lkfgyx8mx99fdirlhi9lbhhzhrpcyr";
        authors = [
          "softprops <d.tangren@gmail.com>"
        ];
        dependencies = [
          {
            name = "hermit-abi";
            packageId = "hermit-abi";
            target = {
              target,
              features,
            }: ("hermit" == target."os");
          }
          {
            name = "libc";
            packageId = "libc";
            usesDefaultFeatures = false;
            target = {
              target,
              features,
            }: (target."unix" or false);
          }
          {
            name = "winapi";
            packageId = "winapi";
            target = {
              target,
              features,
            }: (target."windows" or false);
            features = ["consoleapi" "processenv" "minwinbase" "minwindef" "winbase"];
          }
        ];
      };
      "bitflags 1.3.2" = rec {
        crateName = "bitflags";
        version = "1.3.2";
        edition = "2018";
        sha256 = "12ki6w8gn1ldq7yz9y680llwk5gmrhrzszaa17g1sbrw2r2qvwxy";
        authors = [
          "The Rust Project Developers"
        ];
        features = {
          "compiler_builtins" = ["dep:compiler_builtins"];
          "core" = ["dep:core"];
          "rustc-dep-of-std" = ["core" "compiler_builtins"];
        };
        resolvedDefaultFeatures = ["default"];
      };
      "bitflags 2.4.2" = rec {
        crateName = "bitflags";
        version = "2.4.2";
        edition = "2021";
        sha256 = "1pqd142hyqlzr7p9djxq2ff0jx07a2sb2xp9lhw69cbf80s0jmzd";
        authors = [
          "The Rust Project Developers"
        ];
        features = {
          "arbitrary" = ["dep:arbitrary"];
          "bytemuck" = ["dep:bytemuck"];
          "compiler_builtins" = ["dep:compiler_builtins"];
          "core" = ["dep:core"];
          "rustc-dep-of-std" = ["core" "compiler_builtins"];
          "serde" = ["dep:serde"];
        };
      };
      "cfg-if" = rec {
        crateName = "cfg-if";
        version = "1.0.0";
        edition = "2018";
        sha256 = "1za0vb97n4brpzpv8lsbnzmq5r8f2b0cpqqr0sy8h5bn751xxwds";
        authors = [
          "Alex Crichton <alex@alexcrichton.com>"
        ];
        features = {
          "compiler_builtins" = ["dep:compiler_builtins"];
          "core" = ["dep:core"];
          "rustc-dep-of-std" = ["core" "compiler_builtins"];
        };
      };
      "clap" = rec {
        crateName = "clap";
        version = "2.34.0";
        edition = "2018";
        sha256 = "071q5d8jfwbazi6zhik9xwpacx5i6kb2vkzy060vhf0c3120aqd0";
        authors = [
          "Kevin K. <kbknapp@gmail.com>"
        ];
        dependencies = [
          {
            name = "bitflags";
            packageId = "bitflags 1.3.2";
          }
          {
            name = "textwrap";
            packageId = "textwrap";
          }
          {
            name = "unicode-width";
            packageId = "unicode-width";
          }
        ];
        features = {
          "ansi_term" = ["dep:ansi_term"];
          "atty" = ["dep:atty"];
          "clippy" = ["dep:clippy"];
          "color" = ["ansi_term" "atty"];
          "default" = ["suggestions" "color" "vec_map"];
          "doc" = ["yaml"];
          "strsim" = ["dep:strsim"];
          "suggestions" = ["strsim"];
          "term_size" = ["dep:term_size"];
          "vec_map" = ["dep:vec_map"];
          "wrap_help" = ["term_size" "textwrap/term_size"];
          "yaml" = ["yaml-rust"];
          "yaml-rust" = ["dep:yaml-rust"];
        };
      };
      "csv" = rec {
        crateName = "csv";
        version = "1.3.0";
        edition = "2021";
        sha256 = "1zjrlycvn44fxd9m8nwy8x33r9ncgk0k3wvy4fnvb9rpsks4ymxc";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "csv-core";
            packageId = "csv-core";
          }
          {
            name = "itoa";
            packageId = "itoa";
          }
          {
            name = "ryu";
            packageId = "ryu";
          }
          {
            name = "serde";
            packageId = "serde";
          }
        ];
        devDependencies = [
          {
            name = "serde";
            packageId = "serde";
            features = ["derive"];
          }
        ];
      };
      "csv-core" = rec {
        crateName = "csv-core";
        version = "0.1.11";
        edition = "2018";
        sha256 = "0w7s7qa60xb054rqddpyg53xq2b29sf3rbhcl8sbdx02g4yjpyjy";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "memchr";
            packageId = "memchr";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "libc" = ["memchr/libc"];
        };
        resolvedDefaultFeatures = ["default"];
      };
      "dirs-next" = rec {
        crateName = "dirs-next";
        version = "2.0.0";
        edition = "2018";
        sha256 = "1q9kr151h9681wwp6is18750ssghz6j9j7qm7qi1ngcwy7mzi35r";
        authors = [
          "The @xdg-rs members"
        ];
        dependencies = [
          {
            name = "cfg-if";
            packageId = "cfg-if";
          }
          {
            name = "dirs-sys-next";
            packageId = "dirs-sys-next";
          }
        ];
      };
      "dirs-sys-next" = rec {
        crateName = "dirs-sys-next";
        version = "0.1.2";
        edition = "2018";
        sha256 = "0kavhavdxv4phzj4l0psvh55hszwnr0rcz8sxbvx20pyqi2a3gaf";
        authors = [
          "The @xdg-rs members"
        ];
        dependencies = [
          {
            name = "libc";
            packageId = "libc";
            target = {
              target,
              features,
            }: (target."unix" or false);
          }
          {
            name = "redox_users";
            packageId = "redox_users";
            usesDefaultFeatures = false;
            target = {
              target,
              features,
            }: ("redox" == target."os");
          }
          {
            name = "winapi";
            packageId = "winapi";
            target = {
              target,
              features,
            }: (target."windows" or false);
            features = ["knownfolders" "objbase" "shlobj" "winbase" "winerror"];
          }
        ];
      };
      "encode_unicode" = rec {
        crateName = "encode_unicode";
        version = "1.0.0";
        edition = "2021";
        sha256 = "1h5j7j7byi289by63s3w4a8b3g6l5ccdrws7a67nn07vdxj77ail";
        authors = [
          "Torbjørn Birch Moltu <t.b.moltu@lyse.net>"
        ];
        features = {
          "ascii" = ["dep:ascii"];
          "default" = ["std"];
        };
        resolvedDefaultFeatures = ["default" "std"];
      };
      "equivalent" = rec {
        crateName = "equivalent";
        version = "1.0.1";
        edition = "2015";
        sha256 = "1malmx5f4lkfvqasz319lq6gb3ddg19yzf9s8cykfsgzdmyq0hsl";
      };
      "getrandom" = rec {
        crateName = "getrandom";
        version = "0.2.12";
        edition = "2018";
        sha256 = "1d8jb9bv38nkwlqqdjcav6gxckgwc9g30pm3qq506rvncpm9400r";
        authors = [
          "The Rand Project Developers"
        ];
        dependencies = [
          {
            name = "cfg-if";
            packageId = "cfg-if";
          }
          {
            name = "libc";
            packageId = "libc";
            usesDefaultFeatures = false;
            target = {
              target,
              features,
            }: (target."unix" or false);
          }
          {
            name = "wasi";
            packageId = "wasi";
            usesDefaultFeatures = false;
            target = {
              target,
              features,
            }: ("wasi" == target."os");
          }
        ];
        features = {
          "compiler_builtins" = ["dep:compiler_builtins"];
          "core" = ["dep:core"];
          "js" = ["wasm-bindgen" "js-sys"];
          "js-sys" = ["dep:js-sys"];
          "rustc-dep-of-std" = ["compiler_builtins" "core" "libc/rustc-dep-of-std" "wasi/rustc-dep-of-std"];
          "wasm-bindgen" = ["dep:wasm-bindgen"];
        };
        resolvedDefaultFeatures = ["std"];
      };
      "hashbrown" = rec {
        crateName = "hashbrown";
        version = "0.14.3";
        edition = "2021";
        sha256 = "012nywlg0lj9kwanh69my5x67vjlfmzfi9a0rq4qvis2j8fil3r9";
        authors = [
          "Amanieu d'Antras <amanieu@gmail.com>"
        ];
        features = {
          "ahash" = ["dep:ahash"];
          "alloc" = ["dep:alloc"];
          "allocator-api2" = ["dep:allocator-api2"];
          "compiler_builtins" = ["dep:compiler_builtins"];
          "core" = ["dep:core"];
          "default" = ["ahash" "inline-more" "allocator-api2"];
          "equivalent" = ["dep:equivalent"];
          "nightly" = ["allocator-api2?/nightly" "bumpalo/allocator_api"];
          "rayon" = ["dep:rayon"];
          "rkyv" = ["dep:rkyv"];
          "rustc-dep-of-std" = ["nightly" "core" "compiler_builtins" "alloc" "rustc-internal-api"];
          "serde" = ["dep:serde"];
        };
        resolvedDefaultFeatures = ["raw"];
      };
      "heck" = rec {
        crateName = "heck";
        version = "0.3.3";
        edition = "2018";
        sha256 = "0b0kkr790p66lvzn9nsmfjvydrbmh9z5gb664jchwgw64vxiwqkd";
        authors = [
          "Without Boats <woboats@gmail.com>"
        ];
        dependencies = [
          {
            name = "unicode-segmentation";
            packageId = "unicode-segmentation";
          }
        ];
      };
      "hermit-abi" = rec {
        crateName = "hermit-abi";
        version = "0.1.19";
        edition = "2018";
        sha256 = "0cxcm8093nf5fyn114w8vxbrbcyvv91d4015rdnlgfll7cs6gd32";
        authors = [
          "Stefan Lankes"
        ];
        dependencies = [
          {
            name = "libc";
            packageId = "libc";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "compiler_builtins" = ["dep:compiler_builtins"];
          "core" = ["dep:core"];
          "rustc-dep-of-std" = ["core" "compiler_builtins/rustc-dep-of-std" "libc/rustc-dep-of-std"];
        };
        resolvedDefaultFeatures = ["default"];
      };
      "indexmap" = rec {
        crateName = "indexmap";
        version = "2.2.2";
        edition = "2021";
        sha256 = "087mafd9f98rp1xk2jc1rsp5yyqz63yi30cy8yx6c8s14bj2ljw2";
        dependencies = [
          {
            name = "equivalent";
            packageId = "equivalent";
            usesDefaultFeatures = false;
          }
          {
            name = "hashbrown";
            packageId = "hashbrown";
            usesDefaultFeatures = false;
            features = ["raw"];
          }
        ];
        features = {
          "arbitrary" = ["dep:arbitrary"];
          "default" = ["std"];
          "quickcheck" = ["dep:quickcheck"];
          "rayon" = ["dep:rayon"];
          "rustc-rayon" = ["dep:rustc-rayon"];
          "serde" = ["dep:serde"];
        };
        resolvedDefaultFeatures = ["default" "std"];
      };
      "itoa" = rec {
        crateName = "itoa";
        version = "1.0.10";
        edition = "2018";
        sha256 = "0k7xjfki7mnv6yzjrbnbnjllg86acmbnk4izz2jmm1hx2wd6v95i";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        features = {
          "no-panic" = ["dep:no-panic"];
        };
      };
      "jtab" = rec {
        crateName = "jtab";
        version = "0.7.1";
        edition = "2018";
        crateBin = [
          {
            name = "jtab";
            path = "src/main.rs";
            requiredFeatures = [];
          }
        ];
        # We can't filter paths with references in Nix 2.4
        # See https://github.com/NixOS/nix/issues/5410
        src =
          if ((lib.versionOlder builtins.nixVersion "2.4pre20211007") || (lib.versionOlder "2.5" builtins.nixVersion))
          then
            lib.cleanSourceWith {
              filter = sourceFilter;
              src = _src;
            }
          else _src;
        authors = [
          "wlezzar <walid.lezzar@gmail.com>"
        ];
        dependencies = [
          {
            name = "anyhow";
            packageId = "anyhow";
          }
          {
            name = "csv";
            packageId = "csv";
          }
          {
            name = "prettytable-rs";
            packageId = "prettytable-rs";
          }
          {
            name = "regex";
            packageId = "regex";
          }
          {
            name = "serde_json";
            packageId = "serde_json";
            features = ["preserve_order"];
          }
          {
            name = "structopt";
            packageId = "structopt";
            usesDefaultFeatures = false;
          }
          {
            name = "term";
            packageId = "term";
          }
          {
            name = "thiserror";
            packageId = "thiserror";
          }
          {
            name = "yaml-rust";
            packageId = "yaml-rust";
          }
        ];
      };
      "lazy_static" = rec {
        crateName = "lazy_static";
        version = "1.4.0";
        edition = "2015";
        sha256 = "0in6ikhw8mgl33wjv6q6xfrb5b9jr16q8ygjy803fay4zcisvaz2";
        authors = [
          "Marvin Löbel <loebel.marvin@gmail.com>"
        ];
        features = {
          "spin" = ["dep:spin"];
          "spin_no_std" = ["spin"];
        };
      };
      "libc" = rec {
        crateName = "libc";
        version = "0.2.153";
        edition = "2015";
        sha256 = "1gg7m1ils5dms5miq9fyllrcp0jxnbpgkx71chd2i0lafa8qy6cw";
        authors = [
          "The Rust Project Developers"
        ];
        features = {
          "default" = ["std"];
          "rustc-dep-of-std" = ["align" "rustc-std-workspace-core"];
          "rustc-std-workspace-core" = ["dep:rustc-std-workspace-core"];
          "use_std" = ["std"];
        };
        resolvedDefaultFeatures = ["default" "std"];
      };
      "libredox" = rec {
        crateName = "libredox";
        version = "0.0.1";
        edition = "2021";
        sha256 = "1s2fh4ikpp9xl0lsl01pi0n8pw1q9s3ld452vd8qh1v63v537j45";
        authors = [
          "4lDO2 <4lDO2@protonmail.com>"
        ];
        dependencies = [
          {
            name = "bitflags";
            packageId = "bitflags 2.4.2";
          }
          {
            name = "libc";
            packageId = "libc";
          }
          {
            name = "redox_syscall";
            packageId = "redox_syscall";
          }
        ];
        features = {
          "default" = ["scheme" "call"];
          "scheme" = ["call"];
        };
        resolvedDefaultFeatures = ["call"];
      };
      "linked-hash-map" = rec {
        crateName = "linked-hash-map";
        version = "0.5.6";
        edition = "2015";
        sha256 = "03vpgw7x507g524nx5i1jf5dl8k3kv0fzg8v3ip6qqwbpkqww5q7";
        authors = [
          "Stepan Koltsov <stepan.koltsov@gmail.com>"
          "Andrew Paseltiner <apaseltiner@gmail.com>"
        ];
        features = {
          "heapsize" = ["dep:heapsize"];
          "heapsize_impl" = ["heapsize"];
          "serde" = ["dep:serde"];
          "serde_impl" = ["serde"];
        };
      };
      "memchr" = rec {
        crateName = "memchr";
        version = "2.7.1";
        edition = "2021";
        sha256 = "0jf1kicqa4vs9lyzj4v4y1p90q0dh87hvhsdd5xvhnp527sw8gaj";
        authors = [
          "Andrew Gallant <jamslam@gmail.com>"
          "bluss"
        ];
        features = {
          "compiler_builtins" = ["dep:compiler_builtins"];
          "core" = ["dep:core"];
          "default" = ["std"];
          "logging" = ["dep:log"];
          "rustc-dep-of-std" = ["core" "compiler_builtins"];
          "std" = ["alloc"];
          "use_std" = ["std"];
        };
        resolvedDefaultFeatures = ["alloc" "std"];
      };
      "prettytable-rs" = rec {
        crateName = "prettytable-rs";
        version = "0.9.0";
        edition = "2018";
        crateBin = [];
        sha256 = "00gqr25ya7cc870pk6abkm0bdxgvn54fpzbzjciivd939jvmqdsz";
        libName = "prettytable";
        authors = [
          "Pierre-Henri Symoneaux"
        ];
        dependencies = [
          {
            name = "atty";
            packageId = "atty";
          }
          {
            name = "csv";
            packageId = "csv";
            optional = true;
          }
          {
            name = "encode_unicode";
            packageId = "encode_unicode";
          }
          {
            name = "lazy_static";
            packageId = "lazy_static";
          }
          {
            name = "term";
            packageId = "term";
          }
          {
            name = "unicode-width";
            packageId = "unicode-width";
          }
        ];
        features = {
          "csv" = ["dep:csv"];
          "default" = ["win_crlf" "csv"];
        };
        resolvedDefaultFeatures = ["csv" "default" "win_crlf"];
      };
      "proc-macro-error" = rec {
        crateName = "proc-macro-error";
        version = "1.0.4";
        edition = "2018";
        sha256 = "1373bhxaf0pagd8zkyd03kkx6bchzf6g0dkwrwzsnal9z47lj9fs";
        authors = [
          "CreepySkeleton <creepy-skeleton@yandex.ru>"
        ];
        dependencies = [
          {
            name = "proc-macro-error-attr";
            packageId = "proc-macro-error-attr";
          }
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
          }
          {
            name = "quote";
            packageId = "quote";
          }
          {
            name = "syn";
            packageId = "syn 1.0.109";
            optional = true;
            usesDefaultFeatures = false;
          }
        ];
        buildDependencies = [
          {
            name = "version_check";
            packageId = "version_check";
          }
        ];
        features = {
          "default" = ["syn-error"];
          "syn" = ["dep:syn"];
          "syn-error" = ["syn"];
        };
        resolvedDefaultFeatures = ["default" "syn" "syn-error"];
      };
      "proc-macro-error-attr" = rec {
        crateName = "proc-macro-error-attr";
        version = "1.0.4";
        edition = "2018";
        sha256 = "0sgq6m5jfmasmwwy8x4mjygx5l7kp8s4j60bv25ckv2j1qc41gm1";
        procMacro = true;
        authors = [
          "CreepySkeleton <creepy-skeleton@yandex.ru>"
        ];
        dependencies = [
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
          }
          {
            name = "quote";
            packageId = "quote";
          }
        ];
        buildDependencies = [
          {
            name = "version_check";
            packageId = "version_check";
          }
        ];
      };
      "proc-macro2" = rec {
        crateName = "proc-macro2";
        version = "1.0.78";
        edition = "2021";
        sha256 = "1bjak27pqdn4f4ih1c9nr3manzyavsgqmf76ygw9k76q8pb2lhp2";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
          "Alex Crichton <alex@alexcrichton.com>"
        ];
        dependencies = [
          {
            name = "unicode-ident";
            packageId = "unicode-ident";
          }
        ];
        features = {
          "default" = ["proc-macro"];
        };
        resolvedDefaultFeatures = ["default" "proc-macro"];
      };
      "quote" = rec {
        crateName = "quote";
        version = "1.0.35";
        edition = "2018";
        sha256 = "1vv8r2ncaz4pqdr78x7f138ka595sp2ncr1sa2plm4zxbsmwj7i9";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "default" = ["proc-macro"];
          "proc-macro" = ["proc-macro2/proc-macro"];
        };
        resolvedDefaultFeatures = ["default" "proc-macro"];
      };
      "redox_syscall" = rec {
        crateName = "redox_syscall";
        version = "0.4.1";
        edition = "2018";
        sha256 = "1aiifyz5dnybfvkk4cdab9p2kmphag1yad6iknc7aszlxxldf8j7";
        libName = "syscall";
        authors = [
          "Jeremy Soller <jackpot51@gmail.com>"
        ];
        dependencies = [
          {
            name = "bitflags";
            packageId = "bitflags 1.3.2";
          }
        ];
        features = {
          "core" = ["dep:core"];
          "rustc-dep-of-std" = ["core" "bitflags/rustc-dep-of-std"];
        };
      };
      "redox_users" = rec {
        crateName = "redox_users";
        version = "0.4.4";
        edition = "2021";
        sha256 = "1d1c7dhbb62sh8jrq9dhvqcyxqsh3wg8qknsi94iwq3r0wh7k151";
        authors = [
          "Jose Narvaez <goyox86@gmail.com>"
          "Wesley Hershberger <mggmugginsmc@gmail.com>"
        ];
        dependencies = [
          {
            name = "getrandom";
            packageId = "getrandom";
            features = ["std"];
          }
          {
            name = "libredox";
            packageId = "libredox";
            usesDefaultFeatures = false;
            features = ["call"];
          }
          {
            name = "thiserror";
            packageId = "thiserror";
          }
        ];
        features = {
          "auth" = ["rust-argon2" "zeroize"];
          "default" = ["auth"];
          "rust-argon2" = ["dep:rust-argon2"];
          "zeroize" = ["dep:zeroize"];
        };
      };
      "regex" = rec {
        crateName = "regex";
        version = "1.10.3";
        edition = "2021";
        sha256 = "05cvihqy0wgnh9i8a9y2n803n5azg2h0b7nlqy6rsvxhy00vwbdn";
        authors = [
          "The Rust Project Developers"
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "aho-corasick";
            packageId = "aho-corasick";
            optional = true;
            usesDefaultFeatures = false;
          }
          {
            name = "memchr";
            packageId = "memchr";
            optional = true;
            usesDefaultFeatures = false;
          }
          {
            name = "regex-automata";
            packageId = "regex-automata";
            usesDefaultFeatures = false;
            features = ["alloc" "syntax" "meta" "nfa-pikevm"];
          }
          {
            name = "regex-syntax";
            packageId = "regex-syntax";
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "default" = ["std" "perf" "unicode" "regex-syntax/default"];
          "logging" = ["aho-corasick?/logging" "memchr?/logging" "regex-automata/logging"];
          "perf" = ["perf-cache" "perf-dfa" "perf-onepass" "perf-backtrack" "perf-inline" "perf-literal"];
          "perf-backtrack" = ["regex-automata/nfa-backtrack"];
          "perf-dfa" = ["regex-automata/hybrid"];
          "perf-dfa-full" = ["regex-automata/dfa-build" "regex-automata/dfa-search"];
          "perf-inline" = ["regex-automata/perf-inline"];
          "perf-literal" = ["dep:aho-corasick" "dep:memchr" "regex-automata/perf-literal"];
          "perf-onepass" = ["regex-automata/dfa-onepass"];
          "std" = ["aho-corasick?/std" "memchr?/std" "regex-automata/std" "regex-syntax/std"];
          "unicode" = ["unicode-age" "unicode-bool" "unicode-case" "unicode-gencat" "unicode-perl" "unicode-script" "unicode-segment" "regex-automata/unicode" "regex-syntax/unicode"];
          "unicode-age" = ["regex-automata/unicode-age" "regex-syntax/unicode-age"];
          "unicode-bool" = ["regex-automata/unicode-bool" "regex-syntax/unicode-bool"];
          "unicode-case" = ["regex-automata/unicode-case" "regex-syntax/unicode-case"];
          "unicode-gencat" = ["regex-automata/unicode-gencat" "regex-syntax/unicode-gencat"];
          "unicode-perl" = ["regex-automata/unicode-perl" "regex-automata/unicode-word-boundary" "regex-syntax/unicode-perl"];
          "unicode-script" = ["regex-automata/unicode-script" "regex-syntax/unicode-script"];
          "unicode-segment" = ["regex-automata/unicode-segment" "regex-syntax/unicode-segment"];
          "unstable" = ["pattern"];
          "use_std" = ["std"];
        };
        resolvedDefaultFeatures = ["default" "perf" "perf-backtrack" "perf-cache" "perf-dfa" "perf-inline" "perf-literal" "perf-onepass" "std" "unicode" "unicode-age" "unicode-bool" "unicode-case" "unicode-gencat" "unicode-perl" "unicode-script" "unicode-segment"];
      };
      "regex-automata" = rec {
        crateName = "regex-automata";
        version = "0.4.5";
        edition = "2021";
        sha256 = "1karc80mx15z435rm1jg3sqylnc58nxi15gqypcd1inkzzpqgfav";
        authors = [
          "The Rust Project Developers"
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        dependencies = [
          {
            name = "aho-corasick";
            packageId = "aho-corasick";
            optional = true;
            usesDefaultFeatures = false;
          }
          {
            name = "memchr";
            packageId = "memchr";
            optional = true;
            usesDefaultFeatures = false;
          }
          {
            name = "regex-syntax";
            packageId = "regex-syntax";
            optional = true;
            usesDefaultFeatures = false;
          }
        ];
        features = {
          "default" = ["std" "syntax" "perf" "unicode" "meta" "nfa" "dfa" "hybrid"];
          "dfa" = ["dfa-build" "dfa-search" "dfa-onepass"];
          "dfa-build" = ["nfa-thompson" "dfa-search"];
          "dfa-onepass" = ["nfa-thompson"];
          "hybrid" = ["alloc" "nfa-thompson"];
          "internal-instrument" = ["internal-instrument-pikevm"];
          "internal-instrument-pikevm" = ["logging" "std"];
          "logging" = ["dep:log" "aho-corasick?/logging" "memchr?/logging"];
          "meta" = ["syntax" "nfa-pikevm"];
          "nfa" = ["nfa-thompson" "nfa-pikevm" "nfa-backtrack"];
          "nfa-backtrack" = ["nfa-thompson"];
          "nfa-pikevm" = ["nfa-thompson"];
          "nfa-thompson" = ["alloc"];
          "perf" = ["perf-inline" "perf-literal"];
          "perf-literal" = ["perf-literal-substring" "perf-literal-multisubstring"];
          "perf-literal-multisubstring" = ["std" "dep:aho-corasick"];
          "perf-literal-substring" = ["aho-corasick?/perf-literal" "dep:memchr"];
          "std" = ["regex-syntax?/std" "memchr?/std" "aho-corasick?/std" "alloc"];
          "syntax" = ["dep:regex-syntax" "alloc"];
          "unicode" = ["unicode-age" "unicode-bool" "unicode-case" "unicode-gencat" "unicode-perl" "unicode-script" "unicode-segment" "unicode-word-boundary" "regex-syntax?/unicode"];
          "unicode-age" = ["regex-syntax?/unicode-age"];
          "unicode-bool" = ["regex-syntax?/unicode-bool"];
          "unicode-case" = ["regex-syntax?/unicode-case"];
          "unicode-gencat" = ["regex-syntax?/unicode-gencat"];
          "unicode-perl" = ["regex-syntax?/unicode-perl"];
          "unicode-script" = ["regex-syntax?/unicode-script"];
          "unicode-segment" = ["regex-syntax?/unicode-segment"];
        };
        resolvedDefaultFeatures = ["alloc" "dfa-onepass" "hybrid" "meta" "nfa-backtrack" "nfa-pikevm" "nfa-thompson" "perf-inline" "perf-literal" "perf-literal-multisubstring" "perf-literal-substring" "std" "syntax" "unicode" "unicode-age" "unicode-bool" "unicode-case" "unicode-gencat" "unicode-perl" "unicode-script" "unicode-segment" "unicode-word-boundary"];
      };
      "regex-syntax" = rec {
        crateName = "regex-syntax";
        version = "0.8.2";
        edition = "2021";
        sha256 = "17rd2s8xbiyf6lb4aj2nfi44zqlj98g2ays8zzj2vfs743k79360";
        authors = [
          "The Rust Project Developers"
          "Andrew Gallant <jamslam@gmail.com>"
        ];
        features = {
          "arbitrary" = ["dep:arbitrary"];
          "default" = ["std" "unicode"];
          "unicode" = ["unicode-age" "unicode-bool" "unicode-case" "unicode-gencat" "unicode-perl" "unicode-script" "unicode-segment"];
        };
        resolvedDefaultFeatures = ["default" "std" "unicode" "unicode-age" "unicode-bool" "unicode-case" "unicode-gencat" "unicode-perl" "unicode-script" "unicode-segment"];
      };
      "rustversion" = rec {
        crateName = "rustversion";
        version = "1.0.14";
        edition = "2018";
        sha256 = "1x1pz1yynk5xzzrazk2svmidj69jhz89dz5vrc28sixl20x1iz3z";
        procMacro = true;
        build = "build/build.rs";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
      };
      "ryu" = rec {
        crateName = "ryu";
        version = "1.0.16";
        edition = "2018";
        sha256 = "0k7b90xr48ag5bzmfjp82rljasw2fx28xr3bg1lrpx7b5sljm3gr";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        features = {
          "no-panic" = ["dep:no-panic"];
        };
      };
      "serde" = rec {
        crateName = "serde";
        version = "1.0.196";
        edition = "2018";
        sha256 = "0civrvhbwwk442xhlkfdkkdn478by486qxmackq6k3501zk2c047";
        authors = [
          "Erick Tryzelaar <erick.tryzelaar@gmail.com>"
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "serde_derive";
            packageId = "serde_derive";
            optional = true;
          }
          {
            name = "serde_derive";
            packageId = "serde_derive";
            target = {
              target,
              features,
            }:
              false;
          }
        ];
        devDependencies = [
          {
            name = "serde_derive";
            packageId = "serde_derive";
          }
        ];
        features = {
          "default" = ["std"];
          "derive" = ["serde_derive"];
          "serde_derive" = ["dep:serde_derive"];
        };
        resolvedDefaultFeatures = ["default" "std"];
      };
      "serde_derive" = rec {
        crateName = "serde_derive";
        version = "1.0.196";
        edition = "2015";
        sha256 = "0rybziqrfaxkaxrybkhrps7zv3ibxnjdk0fwais16zayr5h57j1k";
        procMacro = true;
        authors = [
          "Erick Tryzelaar <erick.tryzelaar@gmail.com>"
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
            usesDefaultFeatures = false;
            features = ["proc-macro"];
          }
          {
            name = "quote";
            packageId = "quote";
            usesDefaultFeatures = false;
            features = ["proc-macro"];
          }
          {
            name = "syn";
            packageId = "syn 2.0.48";
            usesDefaultFeatures = false;
            features = ["clone-impls" "derive" "parsing" "printing" "proc-macro"];
          }
        ];
        features = {
        };
        resolvedDefaultFeatures = ["default"];
      };
      "serde_json" = rec {
        crateName = "serde_json";
        version = "1.0.113";
        edition = "2021";
        sha256 = "0ycaiff7ar4qx5sy9kvi1kv9rnnfl15kcfmhxiiwknn3n5q1p039";
        authors = [
          "Erick Tryzelaar <erick.tryzelaar@gmail.com>"
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "indexmap";
            packageId = "indexmap";
            optional = true;
          }
          {
            name = "itoa";
            packageId = "itoa";
          }
          {
            name = "ryu";
            packageId = "ryu";
          }
          {
            name = "serde";
            packageId = "serde";
            usesDefaultFeatures = false;
          }
        ];
        devDependencies = [
          {
            name = "serde";
            packageId = "serde";
            features = ["derive"];
          }
        ];
        features = {
          "alloc" = ["serde/alloc"];
          "default" = ["std"];
          "indexmap" = ["dep:indexmap"];
          "preserve_order" = ["indexmap" "std"];
          "std" = ["serde/std"];
        };
        resolvedDefaultFeatures = ["default" "indexmap" "preserve_order" "std"];
      };
      "structopt" = rec {
        crateName = "structopt";
        version = "0.3.26";
        edition = "2018";
        sha256 = "043sg3qxllann6q9i71d05qp3q13scmcvhxhd950ka2v8ij5qsqc";
        authors = [
          "Guillaume Pinot <texitoi@texitoi.eu>"
          "others"
        ];
        dependencies = [
          {
            name = "clap";
            packageId = "clap";
            usesDefaultFeatures = false;
          }
          {
            name = "lazy_static";
            packageId = "lazy_static";
          }
          {
            name = "structopt-derive";
            packageId = "structopt-derive";
          }
        ];
        features = {
          "color" = ["clap/color"];
          "debug" = ["clap/debug"];
          "default" = ["clap/default"];
          "doc" = ["clap/doc"];
          "lints" = ["clap/lints"];
          "no_cargo" = ["clap/no_cargo"];
          "paw" = ["structopt-derive/paw" "paw_dep"];
          "paw_dep" = ["dep:paw_dep"];
          "suggestions" = ["clap/suggestions"];
          "wrap_help" = ["clap/wrap_help"];
          "yaml" = ["clap/yaml"];
        };
      };
      "structopt-derive" = rec {
        crateName = "structopt-derive";
        version = "0.4.18";
        edition = "2018";
        sha256 = "1q5gcigmvw0cinjxzpyrkflliq5r1ivljmrvfrl3phcwgwraxdfw";
        procMacro = true;
        authors = [
          "Guillaume Pinot <texitoi@texitoi.eu>"
        ];
        dependencies = [
          {
            name = "heck";
            packageId = "heck";
          }
          {
            name = "proc-macro-error";
            packageId = "proc-macro-error";
          }
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
          }
          {
            name = "quote";
            packageId = "quote";
          }
          {
            name = "syn";
            packageId = "syn 1.0.109";
            features = ["full"];
          }
        ];
        features = {
        };
      };
      "syn 1.0.109" = rec {
        crateName = "syn";
        version = "1.0.109";
        edition = "2018";
        sha256 = "0ds2if4600bd59wsv7jjgfkayfzy3hnazs394kz6zdkmna8l3dkj";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
            usesDefaultFeatures = false;
          }
          {
            name = "quote";
            packageId = "quote";
            optional = true;
            usesDefaultFeatures = false;
          }
          {
            name = "unicode-ident";
            packageId = "unicode-ident";
          }
        ];
        features = {
          "default" = ["derive" "parsing" "printing" "clone-impls" "proc-macro"];
          "printing" = ["quote"];
          "proc-macro" = ["proc-macro2/proc-macro" "quote/proc-macro"];
          "quote" = ["dep:quote"];
          "test" = ["syn-test-suite/all-features"];
        };
        resolvedDefaultFeatures = ["clone-impls" "default" "derive" "full" "parsing" "printing" "proc-macro" "quote"];
      };
      "syn 2.0.48" = rec {
        crateName = "syn";
        version = "2.0.48";
        edition = "2021";
        sha256 = "0gqgfygmrxmp8q32lia9p294kdd501ybn6kn2h4gqza0irik2d8g";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
            usesDefaultFeatures = false;
          }
          {
            name = "quote";
            packageId = "quote";
            optional = true;
            usesDefaultFeatures = false;
          }
          {
            name = "unicode-ident";
            packageId = "unicode-ident";
          }
        ];
        features = {
          "default" = ["derive" "parsing" "printing" "clone-impls" "proc-macro"];
          "printing" = ["quote"];
          "proc-macro" = ["proc-macro2/proc-macro" "quote/proc-macro"];
          "quote" = ["dep:quote"];
          "test" = ["syn-test-suite/all-features"];
        };
        resolvedDefaultFeatures = ["clone-impls" "default" "derive" "parsing" "printing" "proc-macro" "quote"];
      };
      "term" = rec {
        crateName = "term";
        version = "0.7.0";
        edition = "2018";
        sha256 = "07xzxmg7dbhlirpyfq09v7cfb9gxn0077sqqvszgjvyrjnngi7f5";
        authors = [
          "The Rust Project Developers"
          "Steven Allen"
        ];
        dependencies = [
          {
            name = "dirs-next";
            packageId = "dirs-next";
          }
          {
            name = "rustversion";
            packageId = "rustversion";
            target = {
              target,
              features,
            }: (target."windows" or false);
          }
          {
            name = "winapi";
            packageId = "winapi";
            target = {
              target,
              features,
            }: (target."windows" or false);
            features = ["consoleapi" "wincon" "handleapi" "fileapi"];
          }
        ];
        features = {
        };
        resolvedDefaultFeatures = ["default"];
      };
      "textwrap" = rec {
        crateName = "textwrap";
        version = "0.11.0";
        edition = "2015";
        sha256 = "0q5hky03ik3y50s9sz25r438bc4nwhqc6dqwynv4wylc807n29nk";
        authors = [
          "Martin Geisler <martin@geisler.net>"
        ];
        dependencies = [
          {
            name = "unicode-width";
            packageId = "unicode-width";
          }
        ];
        features = {
          "hyphenation" = ["dep:hyphenation"];
          "term_size" = ["dep:term_size"];
        };
      };
      "thiserror" = rec {
        crateName = "thiserror";
        version = "1.0.56";
        edition = "2021";
        sha256 = "1b9hnzngjan4d89zjs16i01bcpcnvdwklyh73lj16xk28p37hhym";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "thiserror-impl";
            packageId = "thiserror-impl";
          }
        ];
      };
      "thiserror-impl" = rec {
        crateName = "thiserror-impl";
        version = "1.0.56";
        edition = "2021";
        sha256 = "0w9ldp8fa574ilz4dn7y7scpcq66vdjy59qal8qdpwsh7faal3zs";
        procMacro = true;
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
        dependencies = [
          {
            name = "proc-macro2";
            packageId = "proc-macro2";
          }
          {
            name = "quote";
            packageId = "quote";
          }
          {
            name = "syn";
            packageId = "syn 2.0.48";
          }
        ];
      };
      "unicode-ident" = rec {
        crateName = "unicode-ident";
        version = "1.0.12";
        edition = "2018";
        sha256 = "0jzf1znfpb2gx8nr8mvmyqs1crnv79l57nxnbiszc7xf7ynbjm1k";
        authors = [
          "David Tolnay <dtolnay@gmail.com>"
        ];
      };
      "unicode-segmentation" = rec {
        crateName = "unicode-segmentation";
        version = "1.10.1";
        edition = "2018";
        sha256 = "0dky2hm5k51xy11hc3nk85p533rvghd462b6i0c532b7hl4j9mhx";
        authors = [
          "kwantam <kwantam@gmail.com>"
          "Manish Goregaokar <manishsmail@gmail.com>"
        ];
        features = {
        };
      };
      "unicode-width" = rec {
        crateName = "unicode-width";
        version = "0.1.11";
        edition = "2015";
        sha256 = "11ds4ydhg8g7l06rlmh712q41qsrd0j0h00n1jm74kww3kqk65z5";
        authors = [
          "kwantam <kwantam@gmail.com>"
          "Manish Goregaokar <manishsmail@gmail.com>"
        ];
        features = {
          "compiler_builtins" = ["dep:compiler_builtins"];
          "core" = ["dep:core"];
          "rustc-dep-of-std" = ["std" "core" "compiler_builtins"];
          "std" = ["dep:std"];
        };
        resolvedDefaultFeatures = ["default"];
      };
      "version_check" = rec {
        crateName = "version_check";
        version = "0.9.4";
        edition = "2015";
        sha256 = "0gs8grwdlgh0xq660d7wr80x14vxbizmd8dbp29p2pdncx8lp1s9";
        authors = [
          "Sergio Benitez <sb@sergio.bz>"
        ];
      };
      "wasi" = rec {
        crateName = "wasi";
        version = "0.11.0+wasi-snapshot-preview1";
        edition = "2018";
        sha256 = "08z4hxwkpdpalxjps1ai9y7ihin26y9f476i53dv98v45gkqg3cw";
        authors = [
          "The Cranelift Project Developers"
        ];
        features = {
          "compiler_builtins" = ["dep:compiler_builtins"];
          "core" = ["dep:core"];
          "default" = ["std"];
          "rustc-dep-of-std" = ["compiler_builtins" "core" "rustc-std-workspace-alloc"];
          "rustc-std-workspace-alloc" = ["dep:rustc-std-workspace-alloc"];
        };
      };
      "winapi" = rec {
        crateName = "winapi";
        version = "0.3.9";
        edition = "2015";
        sha256 = "06gl025x418lchw1wxj64ycr7gha83m44cjr5sarhynd9xkrm0sw";
        authors = [
          "Peter Atashian <retep998@gmail.com>"
        ];
        dependencies = [
          {
            name = "winapi-i686-pc-windows-gnu";
            packageId = "winapi-i686-pc-windows-gnu";
            target = {
              target,
              features,
            }: (pkgs.rust.lib.toRustTarget stdenv.hostPlatform == "i686-pc-windows-gnu");
          }
          {
            name = "winapi-x86_64-pc-windows-gnu";
            packageId = "winapi-x86_64-pc-windows-gnu";
            target = {
              target,
              features,
            }: (pkgs.rust.lib.toRustTarget stdenv.hostPlatform == "x86_64-pc-windows-gnu");
          }
        ];
        features = {
          "debug" = ["impl-debug"];
        };
        resolvedDefaultFeatures = ["consoleapi" "fileapi" "handleapi" "knownfolders" "minwinbase" "minwindef" "objbase" "processenv" "shlobj" "winbase" "wincon" "winerror"];
      };
      "winapi-i686-pc-windows-gnu" = rec {
        crateName = "winapi-i686-pc-windows-gnu";
        version = "0.4.0";
        edition = "2015";
        sha256 = "1dmpa6mvcvzz16zg6d5vrfy4bxgg541wxrcip7cnshi06v38ffxc";
        authors = [
          "Peter Atashian <retep998@gmail.com>"
        ];
      };
      "winapi-x86_64-pc-windows-gnu" = rec {
        crateName = "winapi-x86_64-pc-windows-gnu";
        version = "0.4.0";
        edition = "2015";
        sha256 = "0gqq64czqb64kskjryj8isp62m2sgvx25yyj3kpc2myh85w24bki";
        authors = [
          "Peter Atashian <retep998@gmail.com>"
        ];
      };
      "yaml-rust" = rec {
        crateName = "yaml-rust";
        version = "0.4.5";
        edition = "2018";
        sha256 = "118wbqrr4n6wgk5rjjnlrdlahawlxc1bdsx146mwk8f79in97han";
        authors = [
          "Yuheng Chen <yuhengchen@sensetime.com>"
        ];
        dependencies = [
          {
            name = "linked-hash-map";
            packageId = "linked-hash-map";
          }
        ];
      };
    };

    #
    # crate2nix/default.nix (excerpt start)
    #

    /*
     Target (platform) data for conditional dependencies.
    This corresponds roughly to what buildRustCrate is setting.
    */
    makeDefaultTarget = platform: {
      unix = platform.isUnix;
      windows = platform.isWindows;
      fuchsia = true;
      test = false;

      /*
       We are choosing an arbitrary rust version to grab `lib` from,
      which is unfortunate, but `lib` has been version-agnostic the
      whole time so this is good enough for now.
      */
      os = pkgs.rust.lib.toTargetOs platform;
      arch = pkgs.rust.lib.toTargetArch platform;
      family = pkgs.rust.lib.toTargetFamily platform;
      env = "gnu";
      endian =
        if platform.parsed.cpu.significantByte.name == "littleEndian"
        then "little"
        else "big";
      pointer_width = toString platform.parsed.cpu.bits;
      vendor = platform.parsed.vendor.name;
      debug_assertions = false;
    };

    /*
    Filters common temp files and build files.
    */
    # TODO(pkolloch): Substitute with gitignore filter
    sourceFilter = name: type: let
      baseName = builtins.baseNameOf (builtins.toString name);
    in
      ! (
        # Filter out git
        baseName
        == ".gitignore"
        || (type == "directory" && baseName == ".git")
        # Filter out build results
        || (
          type
          == "directory"
          && (
            baseName
            == "target"
            || baseName == "_site"
            || baseName == ".sass-cache"
            || baseName == ".jekyll-metadata"
            || baseName == "build-artifacts"
          )
        )
        # Filter out nix-build result symlinks
        || (
          type == "symlink" && lib.hasPrefix "result" baseName
        )
        # Filter out IDE config
        || (
          type
          == "directory"
          && (
            baseName == ".idea" || baseName == ".vscode"
          )
        )
        || lib.hasSuffix ".iml" baseName
        # Filter out nix build files
        || baseName == "Cargo.nix"
        # Filter out editor backup / swap files.
        || lib.hasSuffix "~" baseName
        || builtins.match "^\\.sw[a-z]$$" baseName != null
        || builtins.match "^\\..*\\.sw[a-z]$$" baseName != null
        || lib.hasSuffix ".tmp" baseName
        || lib.hasSuffix ".bak" baseName
        || baseName == "tests.nix"
      );

    /*
     Returns a crate which depends on successful test execution
    of crate given as the second argument.

    testCrateFlags: list of flags to pass to the test exectuable
    testInputs: list of packages that should be available during test execution
    */
    crateWithTest = {
      crate,
      testCrate,
      testCrateFlags,
      testInputs,
      testPreRun,
      testPostRun,
    }:
      assert builtins.typeOf testCrateFlags == "list";
      assert builtins.typeOf testInputs == "list";
      assert builtins.typeOf testPreRun == "string";
      assert builtins.typeOf testPostRun == "string"; let
        # override the `crate` so that it will build and execute tests instead of
        # building the actual lib and bin targets We just have to pass `--test`
        # to rustc and it will do the right thing.  We execute the tests and copy
        # their log and the test executables to $out for later inspection.
        test = let
          drv =
            testCrate.override
            (
              _: {
                buildTests = true;
              }
            );
          # If the user hasn't set any pre/post commands, we don't want to
          # insert empty lines. This means that any existing users of crate2nix
          # don't get a spurious rebuild unless they set these explicitly.
          testCommand =
            pkgs.lib.concatStringsSep "\n"
            (pkgs.lib.filter (s: s != "") [
              testPreRun
              "$f $testCrateFlags 2>&1 | tee -a $out"
              testPostRun
            ]);
        in
          pkgs.runCommand "run-tests-${testCrate.name}"
          {
            inherit testCrateFlags;
            buildInputs = testInputs;
          } ''
            set -e

            export RUST_BACKTRACE=1

            # recreate a file hierarchy as when running tests with cargo

            # the source for test data
            ${pkgs.xorg.lndir}/bin/lndir ${crate.src}

            # build outputs
            testRoot=target/debug
            mkdir -p $testRoot

            # executables of the crate
            # we copy to prevent std::env::current_exe() to resolve to a store location
            for i in ${crate}/bin/*; do
              cp "$i" "$testRoot"
            done
            chmod +w -R .

            # test harness executables are suffixed with a hash, like cargo does
            # this allows to prevent name collision with the main
            # executables of the crate
            hash=$(basename $out)
            for file in ${drv}/tests/*; do
              f=$testRoot/$(basename $file)-$hash
              cp $file $f
              ${testCommand}
            done
          '';
      in
        pkgs.runCommand "${crate.name}-linked"
        {
          inherit (crate) outputs crateName;
          passthru =
            (crate.passthru or {})
            // {
              inherit test;
            };
        } ''
          echo tested by ${test}
          ${lib.concatMapStringsSep "\n" (output: "ln -s ${crate.${output}} ${"$"}${output}") crate.outputs}
        '';

    /*
    A restricted overridable version of builtRustCratesWithFeatures.
    */
    buildRustCrateWithFeatures = {
      packageId,
      features ? rootFeatures,
      crateOverrides ? defaultCrateOverrides,
      buildRustCrateForPkgsFunc ? null,
      runTests ? false,
      testCrateFlags ? [],
      testInputs ? [],
      # Any command to run immediatelly before a test is executed.
      testPreRun ? "",
      # Any command run immediatelly after a test is executed.
      testPostRun ? "",
    }:
      lib.makeOverridable
      (
        {
          features,
          crateOverrides,
          runTests,
          testCrateFlags,
          testInputs,
          testPreRun,
          testPostRun,
        }: let
          buildRustCrateForPkgsFuncOverriden =
            if buildRustCrateForPkgsFunc != null
            then buildRustCrateForPkgsFunc
            else
              (
                if crateOverrides == pkgs.defaultCrateOverrides
                then buildRustCrateForPkgs
                else
                  pkgs:
                    (buildRustCrateForPkgs pkgs).override {
                      defaultCrateOverrides = crateOverrides;
                    }
              );
          builtRustCrates = builtRustCratesWithFeatures {
            inherit packageId features;
            buildRustCrateForPkgsFunc = buildRustCrateForPkgsFuncOverriden;
            runTests = false;
          };
          builtTestRustCrates = builtRustCratesWithFeatures {
            inherit packageId features;
            buildRustCrateForPkgsFunc = buildRustCrateForPkgsFuncOverriden;
            runTests = true;
          };
          drv = builtRustCrates.crates.${packageId};
          testDrv = builtTestRustCrates.crates.${packageId};
          derivation =
            if runTests
            then
              crateWithTest
              {
                crate = drv;
                testCrate = testDrv;
                inherit testCrateFlags testInputs testPreRun testPostRun;
              }
            else drv;
        in
          derivation
      )
      {inherit features crateOverrides runTests testCrateFlags testInputs testPreRun testPostRun;};

    /*
     Returns an attr set with packageId mapped to the result of buildRustCrateForPkgsFunc
    for the corresponding crate.
    */
    builtRustCratesWithFeatures = {
      packageId,
      features,
      crateConfigs ? crates,
      buildRustCrateForPkgsFunc,
      runTests,
      makeTarget ? makeDefaultTarget,
    } @ args:
      assert (builtins.isAttrs crateConfigs);
      assert (builtins.isString packageId);
      assert (builtins.isList features);
      assert (builtins.isAttrs (makeTarget stdenv.hostPlatform));
      assert (builtins.isBool runTests); let
        rootPackageId = packageId;
        mergedFeatures =
          mergePackageFeatures
          (
            args
            // {
              inherit rootPackageId;
              target = makeTarget stdenv.hostPlatform // {test = runTests;};
            }
          );
        # Memoize built packages so that reappearing packages are only built once.
        builtByPackageIdByPkgs = mkBuiltByPackageIdByPkgs pkgs;
        mkBuiltByPackageIdByPkgs = pkgs: let
          self = {
            crates = lib.mapAttrs (packageId: value: buildByPackageIdForPkgsImpl self pkgs packageId) crateConfigs;
            target = makeTarget pkgs.stdenv.hostPlatform;
            build = mkBuiltByPackageIdByPkgs pkgs.buildPackages;
          };
        in
          self;
        buildByPackageIdForPkgsImpl = self: pkgs: packageId: let
          features = mergedFeatures."${packageId}" or [];
          crateConfig' = crateConfigs."${packageId}";
          crateConfig =
            builtins.removeAttrs crateConfig' ["resolvedDefaultFeatures" "devDependencies"];
          devDependencies =
            lib.optionals
            (runTests && packageId == rootPackageId)
            (crateConfig'.devDependencies or []);
          dependencies = dependencyDerivations {
            inherit features;
            inherit (self) target;
            buildByPackageId = depPackageId:
            # proc_macro crates must be compiled for the build architecture
              if crateConfigs.${depPackageId}.procMacro or false
              then self.build.crates.${depPackageId}
              else self.crates.${depPackageId};
            dependencies =
              (crateConfig.dependencies or [])
              ++ devDependencies;
          };
          buildDependencies = dependencyDerivations {
            inherit features;
            inherit (self.build) target;
            buildByPackageId = depPackageId:
              self.build.crates.${depPackageId};
            dependencies = crateConfig.buildDependencies or [];
          };
          dependenciesWithRenames = let
            buildDeps = filterEnabledDependencies {
              inherit features;
              inherit (self) target;
              dependencies = crateConfig.dependencies or [] ++ devDependencies;
            };
            hostDeps = filterEnabledDependencies {
              inherit features;
              inherit (self.build) target;
              dependencies = crateConfig.buildDependencies or [];
            };
          in
            lib.filter (d: d ? "rename") (hostDeps ++ buildDeps);
          # Crate renames have the form:
          #
          # {
          #    crate_name = [
          #       { version = "1.2.3"; rename = "crate_name01"; }
          #    ];
          #    # ...
          # }
          crateRenames = let
            grouped =
              lib.groupBy
              (dependency: dependency.name)
              dependenciesWithRenames;
            versionAndRename = dep: let
              package = crateConfigs."${dep.packageId}";
            in {
              inherit (dep) rename;
              version = package.version;
            };
          in
            lib.mapAttrs (name: choices: builtins.map versionAndRename choices) grouped;
        in
          buildRustCrateForPkgsFunc pkgs
          (
            crateConfig
            // {
              # https://github.com/NixOS/nixpkgs/issues/218712
              dontStrip = stdenv.hostPlatform.isDarwin;
              src =
                crateConfig.src or (
                  pkgs.fetchurl rec {
                    name = "${crateConfig.crateName}-${crateConfig.version}.tar.gz";
                    # https://www.pietroalbini.org/blog/downloading-crates-io/
                    # Not rate-limited, CDN URL.
                    url = "https://static.crates.io/crates/${crateConfig.crateName}/${crateConfig.crateName}-${crateConfig.version}.crate";
                    sha256 = assert (lib.assertMsg (crateConfig ? sha256) "Missing sha256 for ${name}");
                      crateConfig.sha256;
                  }
                );
              extraRustcOpts = lib.lists.optional (targetFeatures != []) "-C target-feature=${lib.concatMapStringsSep "," (x: "+${x}") targetFeatures}";
              inherit features dependencies buildDependencies crateRenames release;
            }
          );
      in
        builtByPackageIdByPkgs;

    /*
    Returns the actual derivations for the given dependencies.
    */
    dependencyDerivations = {
      buildByPackageId,
      features,
      dependencies,
      target,
    }:
      assert (builtins.isList features);
      assert (builtins.isList dependencies);
      assert (builtins.isAttrs target); let
        enabledDependencies = filterEnabledDependencies {
          inherit dependencies features target;
        };
        depDerivation = dependency: buildByPackageId dependency.packageId;
      in
        map depDerivation enabledDependencies;

    /*
     Returns a sanitized version of val with all values substituted that cannot
    be serialized as JSON.
    */
    sanitizeForJson = val:
      if builtins.isAttrs val
      then lib.mapAttrs (n: v: sanitizeForJson v) val
      else if builtins.isList val
      then builtins.map sanitizeForJson val
      else if builtins.isFunction val
      then "function"
      else val;

    /*
    Returns various tools to debug a crate.
    */
    debugCrate = {
      packageId,
      target ? makeDefaultTarget stdenv.hostPlatform,
    }:
      assert (builtins.isString packageId); let
        debug = rec {
          # The built tree as passed to buildRustCrate.
          buildTree = buildRustCrateWithFeatures {
            buildRustCrateForPkgsFunc = _: lib.id;
            inherit packageId;
          };
          sanitizedBuildTree = sanitizeForJson buildTree;
          dependencyTree =
            sanitizeForJson
            (
              buildRustCrateWithFeatures {
                buildRustCrateForPkgsFunc = _: crate: {
                  "01_crateName" = crate.crateName or false;
                  "02_features" = crate.features or [];
                  "03_dependencies" = crate.dependencies or [];
                };
                inherit packageId;
              }
            );
          mergedPackageFeatures = mergePackageFeatures {
            features = rootFeatures;
            inherit packageId target;
          };
          diffedDefaultPackageFeatures = diffDefaultPackageFeatures {
            inherit packageId target;
          };
        };
      in {internal = debug;};

    /*
     Returns differences between cargo default features and crate2nix default
    features.

    This is useful for verifying the feature resolution in crate2nix.
    */
    diffDefaultPackageFeatures = {
      crateConfigs ? crates,
      packageId,
      target,
    }:
      assert (builtins.isAttrs crateConfigs); let
        prefixValues = prefix: lib.mapAttrs (n: v: {"${prefix}" = v;});
        mergedFeatures =
          prefixValues
          "crate2nix"
          (mergePackageFeatures {
            inherit crateConfigs packageId target;
            features = ["default"];
          });
        configs = prefixValues "cargo" crateConfigs;
        combined = lib.foldAttrs (a: b: a // b) {} [mergedFeatures configs];
        onlyInCargo =
          builtins.attrNames
          (lib.filterAttrs (n: v: !(v ? "crate2nix") && (v ? "cargo")) combined);
        onlyInCrate2Nix =
          builtins.attrNames
          (lib.filterAttrs (n: v: (v ? "crate2nix") && !(v ? "cargo")) combined);
        differentFeatures =
          lib.filterAttrs
          (
            n: v:
              (v ? "crate2nix")
              && (v ? "cargo")
              && (v.crate2nix.features or []) != (v."cargo".resolved_default_features or [])
          )
          combined;
      in
        builtins.toJSON {
          inherit onlyInCargo onlyInCrate2Nix differentFeatures;
        };

    /*
     Returns an attrset mapping packageId to the list of enabled features.

    If multiple paths to a dependency enable different features, the
    corresponding feature sets are merged. Features in rust are additive.
    */
    mergePackageFeatures = {
      crateConfigs ? crates,
      packageId,
      rootPackageId ? packageId,
      features ? rootFeatures,
      dependencyPath ? [crates.${packageId}.crateName],
      featuresByPackageId ? {},
      target,
      # Adds devDependencies to the crate with rootPackageId.
      runTests ? false,
      ...
    } @ args:
      assert (builtins.isAttrs crateConfigs);
      assert (builtins.isString packageId);
      assert (builtins.isString rootPackageId);
      assert (builtins.isList features);
      assert (builtins.isList dependencyPath);
      assert (builtins.isAttrs featuresByPackageId);
      assert (builtins.isAttrs target);
      assert (builtins.isBool runTests); let
        crateConfig = crateConfigs."${packageId}" or (builtins.throw "Package not found: ${packageId}");
        expandedFeatures = expandFeatures (crateConfig.features or {}) features;
        enabledFeatures = enableFeatures (crateConfig.dependencies or []) expandedFeatures;
        depWithResolvedFeatures = dependency: let
          packageId = dependency.packageId;
          features = dependencyFeatures enabledFeatures dependency;
        in {inherit packageId features;};
        resolveDependencies = cache: path: dependencies:
          assert (builtins.isAttrs cache);
          assert (builtins.isList dependencies); let
            enabledDependencies = filterEnabledDependencies {
              inherit dependencies target;
              features = enabledFeatures;
            };
            directDependencies = map depWithResolvedFeatures enabledDependencies;
            foldOverCache = op: lib.foldl op cache directDependencies;
          in
            foldOverCache
            (
              cache: {
                packageId,
                features,
              }: let
                cacheFeatures = cache.${packageId} or [];
                combinedFeatures = sortedUnique (cacheFeatures ++ features);
              in
                if cache ? ${packageId} && cache.${packageId} == combinedFeatures
                then cache
                else
                  mergePackageFeatures {
                    features = combinedFeatures;
                    featuresByPackageId = cache;
                    inherit crateConfigs packageId target runTests rootPackageId;
                  }
            );
        cacheWithSelf = let
          cacheFeatures = featuresByPackageId.${packageId} or [];
          combinedFeatures = sortedUnique (cacheFeatures ++ enabledFeatures);
        in
          featuresByPackageId
          // {
            "${packageId}" = combinedFeatures;
          };
        cacheWithDependencies =
          resolveDependencies cacheWithSelf "dep"
          (
            crateConfig.dependencies or []
            ++ lib.optionals
            (runTests && packageId == rootPackageId)
            (crateConfig.devDependencies or [])
          );
        cacheWithAll =
          resolveDependencies
          cacheWithDependencies "build"
          (crateConfig.buildDependencies or []);
      in
        cacheWithAll;

    /*
    Returns the enabled dependencies given the enabled features.
    */
    filterEnabledDependencies = {
      dependencies,
      features,
      target,
    }:
      assert (builtins.isList dependencies);
      assert (builtins.isList features);
      assert (builtins.isAttrs target);
        lib.filter
        (
          dep: let
            targetFunc = dep.target or (features: true);
          in
            targetFunc {inherit features target;}
            && (
              !(dep.optional or false)
              || builtins.any (doesFeatureEnableDependency dep) features
            )
        )
        dependencies;

    /*
    Returns whether the given feature should enable the given dependency.
    */
    doesFeatureEnableDependency = dependency: feature: let
      name = dependency.rename or dependency.name;
      prefix = "${name}/";
      len = builtins.stringLength prefix;
      startsWithPrefix = builtins.substring 0 len feature == prefix;
    in
      feature == name || feature == "dep:" + name || startsWithPrefix;

    /*
     Returns the expanded features for the given inputFeatures by applying the
    rules in featureMap.

    featureMap is an attribute set which maps feature names to lists of further
    feature names to enable in case this feature is selected.
    */
    expandFeatures = featureMap: inputFeatures:
      assert (builtins.isAttrs featureMap);
      assert (builtins.isList inputFeatures); let
        expandFeaturesNoCycle = oldSeen: inputFeatures:
          if inputFeatures != []
          then let
            # The feature we're currently expanding.
            feature = builtins.head inputFeatures;
            # All the features we've seen/expanded so far, including the one
            # we're currently processing.
            seen = oldSeen // {${feature} = 1;};
            # Expand the feature but be careful to not re-introduce a feature
            # that we've already seen: this can easily cause a cycle, see issue
            # #209.
            enables = builtins.filter (f: !(seen ? "${f}")) (featureMap."${feature}" or []);
          in
            [feature] ++ (expandFeaturesNoCycle seen (builtins.tail inputFeatures ++ enables))
          # No more features left, nothing to expand to.
          else [];
        outFeatures = expandFeaturesNoCycle {} inputFeatures;
      in
        sortedUnique outFeatures;

    /*
     This function adds optional dependencies as features if they are enabled
    indirectly by dependency features. This function mimics Cargo's behavior
    described in a note at:
    https://doc.rust-lang.org/nightly/cargo/reference/features.html#dependency-features
    */
    enableFeatures = dependencies: features:
      assert (builtins.isList features);
      assert (builtins.isList dependencies); let
        additionalFeatures =
          lib.concatMap
          (
            dependency:
              assert (builtins.isAttrs dependency); let
                enabled = builtins.any (doesFeatureEnableDependency dependency) features;
              in
                if (dependency.optional or false) && enabled
                then [(dependency.rename or dependency.name)]
                else []
          )
          dependencies;
      in
        sortedUnique (features ++ additionalFeatures);

    /*
    Returns the actual features for the given dependency.

    features: The features of the crate that refers this dependency.
    */
    dependencyFeatures = features: dependency:
      assert (builtins.isList features);
      assert (builtins.isAttrs dependency); let
        defaultOrNil =
          if dependency.usesDefaultFeatures or true
          then ["default"]
          else [];
        explicitFeatures = dependency.features or [];
        additionalDependencyFeatures = let
          name = dependency.rename or dependency.name;
          stripPrefixMatch = prefix: s:
            if lib.hasPrefix prefix s
            then lib.removePrefix prefix s
            else null;
          extractFeature = feature:
            lib.findFirst
            (f: f != null)
            null
            (map (prefix: stripPrefixMatch prefix feature) [
              (name + "/")
              (name + "?/")
            ]);
          dependencyFeatures = lib.filter (f: f != null) (map extractFeature features);
        in
          dependencyFeatures;
      in
        defaultOrNil ++ explicitFeatures ++ additionalDependencyFeatures;

    /*
    Sorts and removes duplicates from a list of strings.
    */
    sortedUnique = features:
      assert (builtins.isList features);
      assert (builtins.all builtins.isString features); let
        outFeaturesSet = lib.foldl (set: feature: set // {"${feature}" = 1;}) {} features;
        outFeaturesUnique = builtins.attrNames outFeaturesSet;
      in
        builtins.sort (a: b: a < b) outFeaturesUnique;

    deprecationWarning = message: value:
      if strictDeprecation
      then builtins.throw "strictDeprecation enabled, aborting: ${message}"
      else builtins.trace message value;

    #
    # crate2nix/default.nix (excerpt end)
    #
  };
}
